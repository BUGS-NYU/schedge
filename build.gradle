plugins {
  id "java"
  id "application"
  id 'com.avast.gradle.docker-compose' version '0.15.0'
}

mainClassName = 'cli.Main'

// def getenv = { String env_val, default_val ->
//   ext.val = System.getenv(env_val)
//   if (ext.val == null) {
//   return default_val
//   } else return ext.val
// }

java {
  sourceCompatibility = 11
  targetCompatibility = 11
}

tasks.named('wrapper') {
  jarFile = "${project.projectDir}/src/build/gradle/gradle-wrapper.jar"
}

tasks.withType(JavaCompile) {
  options.compilerArgs << "-Xlint:unchecked"
}

repositories {
  mavenCentral()
}

dependencies {
  annotationProcessor(
    "io.javalin.community.openapi:openapi-annotation-processor:5.1.0"
  )

  testImplementation(
    'junit:junit:4.13.2',
    'io.javalin:javalin-testtools:5.1.3',
  )

  implementation(
    // Logging
    "org.slf4j:slf4j-api:2.0.3",
    "org.slf4j:slf4j-simple:2.0.3",

    // Database driver and connection pool
    "org.postgresql:postgresql:42.2.12",
    "com.zaxxer:HikariCP:3.4.1",

    // HTML Parsing
    "org.jsoup:jsoup:1.15.3",

    // Command line arg parsing and progress bar
    "info.picocli:picocli:4.7.0",
    "me.tongfei:progressbar:0.9.5",

    // JSON
    "com.fasterxml.jackson.core:jackson-annotations:2.7.4",

    // Web server framework and documentation
    "io.javalin:javalin:5.1.4",
    // for /openapi route with JSON scheme
    "io.javalin.community.openapi:javalin-openapi-plugin:5.1.0",
  )
}

sourceSets {
  migrations {
    resources {
      srcDirs "src"
      includes = ["migrations/*.sql"]
    }
  }

  main {
    resources {
      source migrations.resources
    }
  }

  test {
    resources {
      source migrations.resources
    }
  }
}

test {
    useJUnit()

    maxHeapSize = '1G'
}

// The build directory should not begin with the same name as the script
allprojects {
  buildDir = ".build"
}

// @TODO use application plugin to make a distribution instead of using
// a fat jar. Fat jars take an annoying amount of time to compile, wheras
// the distribution plugin likely won't, because it has less work to do.
//                   - Albert Liu, Jan 31, 2022 Mon 01:34 EST
jar {
  manifest { attributes ('Main-Class': 'cli.Main') }
  duplicatesStrategy = "include"

  dependsOn configurations.runtimeClasspath

  from {
    configurations.runtimeClasspath.findAll { it.name.endsWith('jar') }.collect { zipTree(it) }
  }
}

composeBuild.dependsOn jar
composeUp.dependsOn composeBuild

/*
I cannot for the fucking life of me figure out a reliable way to remove the dependency between
building and testing. Whatever I guess, I just need the jar I think.
 */

dockerCompose {
  buildBeforeUp = false
  projectName = 'schedge'
}
